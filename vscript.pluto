-- Thanks Hexa for the sweet updater
local auto_update_config = {
    source_url="https://raw.githubusercontent.com/vythrp/vscript/main/vscript.pluto",
    script_relpath=SCRIPT_RELPATH,
}

util.ensure_package_is_installed('lua/auto-updater')
local auto_updater = require('auto-updater')
if auto_updater == true and not is_from_repository then
    auto_updater.run_auto_update(auto_update_config)
end

util.require_natives("3095a.g")

local vscript = menu.my_root()
menu.divider(vscript, "vscript")

local wide_view = 70
local narrow_view = 55
local better_radar_enabled = false
local prev_is_drifting = false
local history_size = 10
local not_drifting_delay_frames = 15
local vx_history = {}
local vy_history = {}
local frames_not_drifting = 0
local is_drifting = false
local drift_angle = 0
local drift_start_time = 0
local min_drift_speed = 25
local current_drift_score = 0
local highest_drift_score = 0
hud_opacity_factor = 255


menu.trigger_commands("sleekminimap on")


local colors = {}

local function update_colors()
    colors.black = {
        ["r"] = 0.0,
        ["g"] = 0.0,
        ["b"] = 0.0,
        ["a"] = 0.8 * (hud_opacity_factor / 255)
    }

    colors.white = {
        ["r"] = 1.0,
        ["g"] = 1.0,
        ["b"] = 1.0,
        ["a"] = 0.15 * (hud_opacity_factor / 255)
    }

    colors.yellow = {
        ["r"] = 1.0,
        ["g"] = 153.0/255,
        ["b"] = 0.0,
        ["a"] = 0.4 * (hud_opacity_factor / 255)
    }

    colors.green = {
        ["r"] = 39.0/255,
        ["g"] = 177.0/255,
        ["b"] = 70.0/255,
        ["a"] = 0.4 * (hud_opacity_factor / 255)
    }

    colors.magenta = {
        ["r"] = 128.0/255,
        ["g"] = 0.0/255,
        ["b"] = 128.0/255,
        ["a"] = 0.5 * (hud_opacity_factor / 255)
    }

    colors.red = {
        ["r"] = 189.0/255,
        ["g"] = 0.0/255,
        ["b"] = 26.0/255,
        ["a"] = 0.6 * (hud_opacity_factor / 255)
    }
    colors.transparent = {
        ["r"] = 0.0,
        ["g"] = 0.0,
        ["b"] = 0.0,
        ["a"] = 0.0
    }
    colors.smoke = {
        ["r"] = 0.2,
        ["g"] = 0.2,
        ["b"] = 0.2,
        ["a"] = 0.1 * (hud_opacity_factor / 255)
    }
end

update_colors()

menu.slider(vscript, "Dash Opacity", {}, "Set the dash opacity.", 0,
            255, hud_opacity_factor, 1,
            function(value)
                hud_opacity_factor = value
                update_colors()
end)

local function bezier_quadratic(p0, p1, p2, t)
    local u = 1 - t
    local tt = t * t
    local uu = u * u
    local x = (uu * p0.x) + (2 * u * t * p1.x) + (tt * p2.x)
    local y = (uu * p0.y) + (2 * u * t * p1.y) + (tt * p2.y)
    return { x = x, y = y }
end

local function draw_quadratic_bezier_curve(p0, p1, p2, segments, color)
    local last_point = p0
    for i = 1, segments do
        local t = i / segments
        local point = bezier_quadratic(p0, p1, p2, t)
        directx.draw_line(last_point.x, last_point.y, point.x, point.y, color)
        last_point = point
    end
end


local function set_FoV(is_wide)
    SET_GAMEPLAY_CAM_RELATIVE_HEADING(0.0)
    SET_FOLLOW_PED_CAM_VIEW_MODE(2)
    local fov = is_wide and wide_view or narrow_view
    menu.trigger_commands("fovtponfoot " .. fov)
    menu.trigger_commands("fovtpinveh " .. fov)
    util.toast("Wide View: " .. (is_wide and "Active" or "Disabled") .. " (" .. fov .. " degrees)")
end

local function toggle_radar(is_enabled)
    DISPLAY_RADAR(not is_enabled)
end

local function toggle_HUD(is_enabled)
    DISPLAY_HUD(is_enabled)
    FORCE_OFF_WANTED_STAR_FLASH(not is_enabled)
    DISPLAY_CASH(is_enabled)
    DISPLAY_AREA_NAME(is_enabled)
end

local function enforce_radar_zoom()
    SET_RADAR_ZOOM(better_radar_enabled and 1400 or 1400)
    SET_BIGMAP_ACTIVE(false, false)
end

util.on_transition_finished(function()
                                enforce_radar_zoom()
end)

local function toggle_muted_sirens(is_muted)
    local vehicle = GET_VEHICLE_PED_IS_USING(players.user_ped())
    SET_VEHICLE_HAS_MUTED_SIRENS(vehicle, is_muted)
end

-- Function to toggle cover.  Thanks Drizz
local function toggle_cover(is_enabled)
    SET_PLAYER_CAN_USE_COVER(players.user(), is_enabled)
end

local function get_fps_color(fps)
    if fps >= 28 then
        return colors.green
    elseif fps >= 20 then
        return colors.yellow
    else
        return colors.red
    end
end

local segment_map = {
    ["0"] = {1, 1, 1, 1, 1, 1, 0, 0},
    ["1"] = {0, 1, 1, 0, 0, 0, 0, 0},
    ["2"] = {1, 1, 0, 1, 1, 0, 1, 0},
    ["3"] = {1, 1, 1, 1, 0, 0, 1, 0},
    ["4"] = {0, 1, 1, 0, 0, 1, 1, 0},
    ["5"] = {1, 0, 1, 1, 0, 1, 1, 0},
    ["6"] = {1, 0, 1, 1, 1, 1, 1, 0},
    ["7"] = {1, 1, 1, 0, 0, 0, 0, 0},
    ["8"] = {1, 1, 1, 1, 1, 1, 1, 0},
    ["9"] = {1, 1, 1, 1, 0, 1, 1, 0},
    ["P"] = {1, 1, 0, 0, 1, 1, 1, 0},
    ["R"] = {1, 1, 1, 0, 1, 1, 1, 0},
}

local function draw_segment(x, y, w, h, active, color)
    if active == 1 then
        directx.draw_rect(x, y, w, h, color)
    end
end

local function draw_char(char, x, y, scale, color)
    local segments = segment_map[char]
    local w, h = 0.1 * scale, 0.02 * scale

    -- Top segment
    draw_segment(x, y, w, h, segments[1], color)
    -- Top-right segment
    draw_segment(x + w - h, y + h, h, w - h, segments[2], color)
    -- Bottom-right segment
    draw_segment(x + w - h, y + 2 * h + w - h, h, w - h, segments[3], color)
    -- Bottom segment
    draw_segment(x, y + 2 * (w - h) + 2 * h, w, h, segments[4], color)
    -- Bottom-left segment
    draw_segment(x - h, y + 2 * h + w - h, h, w - h, segments[5], color)
    -- Top-left segment
    draw_segment(x - h, y + h, h, w - h, segments[6], color)
    -- Middle segment
    draw_segment(x, y + h + w - h, w, h, segments[7], color)
    -- Extra middle segment
    draw_segment(x + w / 2 - h / 2, y + h + w - h, h, w - h, segments[8], color)
end

local function draw_text(text, x, y, scale, color)
    local spacing = 0.15 * scale
    for i = 1, #text do
        local char = text:sub(i, i)
        draw_char(char, x + (i - 1) * spacing, y, scale, color)
    end
end

local function draw_fps(x, y)
    local fps = util.get_tps()
    local color = get_fps_color(fps)
    directx.draw_text(x, y, tostring(fps) .. " FPS", ALIGN_LEFT, 1.0, color, false)
end

local function draw_fps_bar(x, y, width, height)
    local max_fps = 30
    local fps = math.min(math.floor(util.get_tps()), max_fps)
    local bar_width = (fps / max_fps) * width
    local color = get_fps_color(fps)
    directx.draw_rect(x, y, bar_width, height, color)
end


function draw_pulsing_filled_rectangle(x, y, width, height, color, pulse_speed, time)
    directx.draw_rect(x, y, width, height, pulsing_color)
end

local function interpolate_color(color1, color2, factor)
    return {
        r = color1.r * (1 - factor) + color2.r * factor,
        g = color1.g * (1 - factor) + color2.g * factor,
        b = color1.b * (1 - factor) + color2.b * factor,
        a = color1.a * (1 - factor) + color2.a * factor
    }
end

local function draw_gauge_background()
    local radius = 0.32
    local pos_x = 0.5
    local pos_y = 1.35
    local circle_colour = {r = 255/255, g = 153/255, b = 0/255, a = 0.02 * hud_opacity_factor / 255}
    local triangle_side_length = 0.27
    local triangle_color = colors.black
    local height = triangle_side_length * math.sqrt(3) / 2
    local mid_center_x = 0.5
    local center_y = 0.92
    local left_center_x = mid_center_x - triangle_side_length / 2
    local right_center_x = mid_center_x + triangle_side_length / 2
    local triangle_vertices = {
        mid_center_x - triangle_side_length / 2, center_y - height / 2,
        mid_center_x + triangle_side_length / 2, center_y - height / 2,
        mid_center_x, center_y + height / 2
    }
    directx.draw_triangle(
        triangle_vertices[1], triangle_vertices[2],
        triangle_vertices[3], triangle_vertices[4],
        triangle_vertices[5], triangle_vertices[6],
        triangle_color
    )
    local left_center_x = mid_center_x - triangle_side_length / 2
    local inverted_triangle_vertices = {
        left_center_x + triangle_side_length / 2, center_y + height / 2,
        left_center_x - triangle_side_length / 2, center_y + height / 2,
        left_center_x, center_y - height / 2
    }

    directx.draw_triangle(
        inverted_triangle_vertices[1], inverted_triangle_vertices[2],
        inverted_triangle_vertices[3], inverted_triangle_vertices[4],
        inverted_triangle_vertices[5], inverted_triangle_vertices[6],
        triangle_color
    )

    local right_center_x = mid_center_x + triangle_side_length / 2
    local inverted_triangle_vertices = {
        right_center_x + triangle_side_length / 2, center_y + height / 2,
        right_center_x - triangle_side_length / 2, center_y + height / 2,
        right_center_x, center_y - height / 2
    }

    directx.draw_triangle(
        inverted_triangle_vertices[1], inverted_triangle_vertices[2],
        inverted_triangle_vertices[3], inverted_triangle_vertices[4],
        inverted_triangle_vertices[5], inverted_triangle_vertices[6],
        triangle_color
    )
    --directx.draw_circle(pos_x, pos_y, radius, circle_colour, 2)
    --directx.draw_circle(pos_x, pos_y, radius, circle_colour, 3)

    local shift_y = -0.14
    local segments = 300
    local p0 = { x = pos_x - 1.13 * radius , y = pos_y + shift_y}
    local p1 = { x = pos_x, y = 0.5 + shift_y} -- Control point for the curve
    local p2 = { x = pos_x + 1.13 * radius , y = pos_y + shift_y}

    -- draw_quadratic_bezier_curve(p0, p1, p2, segments, {r=1.0,g=1.0,b=1.0,a=1.0})
end

local function draw_gauge_foreground()
    local radius = 0.32
    local pos_x = 0.5
    local pos_y = 1.54
    local color = {r = 1.0, g = 1.0, b = 1.0, a = 1.0}
    color.a = 0.01
    directx.draw_circle(pos_x, pos_y - 0.01, radius - 0.005, color, 2)
    directx.draw_circle(pos_x, pos_y - 0.01, radius - 0.005, color, 3)
end

local function draw_numeric_display(value, pos_x, pos_y, scale, color)
    directx.draw_text(pos_x, pos_y, string.format("%03d", value),
                      ALIGN_CENTRE, scale, color, true)
end

local function draw_segment_bar_speed(pos_x, pos_y, width, height, segments, active_segments)
    local segment_height = (height / segments) * 1.5
    local curve_intensity = 0.7
    local shift_intensity = 0.6

    for i = 0, segments - 1 do
        local y = pos_y - (i * segment_height) - (segment_height * 1.5)
        local x_offset = (i / segments)^3 * curve_intensity - 0.1
        local segment_width = width * (1 - (i / segments) * 0.8)
        local x_shift = (i / segments)^3 * shift_intensity
        if i < active_segments then
            local color_factor = i / (segments - (segments * 0.05))
            local segment_color = interpolate_color(colors.green, colors.red, color_factor)
            directx.draw_rect(pos_x + x_offset - x_shift, y,
                              segment_width, segment_height - 0.005,
                              segment_color)
        else
            directx.draw_rect(pos_x + x_offset - x_shift,
                              y, segment_width, segment_height - 0.005, colors.smoke)
        end
    end
end

local function draw_gauge_speed(pos_x, pos_y, value, max_value)
    local bar_width = 0.1
    local bar_height = 0.1
    local segments = 20
    local active_segments = math.ceil((value / max_value) * segments)

    draw_segment_bar_speed(pos_x, pos_y, bar_width, bar_height, segments, active_segments)

    local num_pos_y = pos_y + bar_height - 0.2
    --draw_numeric_display(value, pos_x, num_pos_y, 1.0, colors.yellow)
    local padded_value = string.format("%03d", value)
    draw_text(padded_value, pos_x - 0.02,
              num_pos_y - 0.01, 0.09, colors.red)
    directx.draw_text(pos_x, num_pos_y + 0.02, "KPH", ALIGN_CENTRE, 0.6, colors.yellow, true)
end

local function draw_segment_bar_rpm(pos_x, pos_y, width, height, segments, active_segments)
    local segment_width = (width / segments) * 1.2
    local curve_intensity = 0.11
    local shift_intensity = 0.05
    local pulse_speed = 10

    for i = 0, segments - 1 do
        local x = pos_x + (i * segment_width) - (segment_width * 1.5)
        local y_offset = - math.cos((i / segments) * math.pi) * curve_intensity - 0.1
        local segment_height = - height * (1 + (i / segments) * 0.5)
        local y_shift = - math.cos((i / segments) * math.pi) * shift_intensity

        if i < active_segments then
            local color_factor = i / (segments - (segments * 0.05))
            local segment_color = interpolate_color(colors.magenta, colors.red, color_factor)

            if active_segments >= segments then
                local pulse_factor = (math.sin(os.clock() * pulse_speed) + 1) / 2
                segment_color = interpolate_color(segment_color, colors.red, pulse_factor)
            end
            directx.draw_rect(x, pos_y + y_offset - y_shift,
                              segment_width - 0.005,
                              segment_height, segment_color)
        else
            directx.draw_rect(x, pos_y + y_offset - y_shift,
                              segment_width - 0.005,
                              segment_height, colors.smoke)
        end
    end
end

local function draw_gauge_rpm(pos_x, pos_y, value, max_value)
    local bar_width = 0.1
    local bar_height = 0.025
    local segments = 20
    local active_segments = math.ceil((value / max_value) * segments)

    draw_segment_bar_rpm(pos_x, pos_y, bar_width, bar_height, segments, active_segments)
    local num_pos_y = pos_y + bar_height - 0.15
    --draw_numeric_display(value, pos_x, num_pos_y, 1.0, colors.yellow)
    local padded_value = string.format("%03d", value)
    draw_text(padded_value, pos_x - 0.015,
              num_pos_y - 0.01, 0.09, colors.red)
    directx.draw_text(pos_x, num_pos_y + 0.02, "% REV", ALIGN_CENTRE, 0.6, colors.yellow, true)
end

local function draw_segmented_vertical_bar(value, max_value, x, y,
                                           width, height, start_color,
                                           end_color, back_color, segments, gap)
    local bar_height = (value / max_value) * height
    local segment_height = (height / segments) - gap

    directx.draw_rect(x, y, width, height, back_color)

    for i = 0, segments - 1 do
        local segment_y = y + height - (i * (segment_height + gap)) - segment_height
        if segment_y >= y + height - bar_height then
            local color_factor = i / (segments - 1)

            local segment_color = interpolate_color(start_color, end_color, color_factor)
            directx.draw_rect(x, segment_y, width, segment_height, segment_color)
        else
            break
        end
    end
end

local function update_v_history(history, v)
    table.insert(history, v)
    if #history > history_size then
        table.remove(history, 1)
    end
end

local function calculate_average(history)
    local sum = 0
    for _, v in ipairs(history) do
        sum = sum + v
    end
    return sum / #history
end

local drift_difficulty_levels = {
    easy = 20.0,
    normal = 30.0,
    hard = 45.0
}

local current_drift_difficulty = drift_difficulty_levels.normal

local easy_toggle, normal_toggle, hard_toggle

local function set_easy()
    current_drift_difficulty = drift_difficulty_levels.easy
    menu.set_value(normal_toggle, false)
    menu.set_value(hard_toggle, false)
end

local function set_normal()
    current_drift_difficulty = drift_difficulty_levels.normal
    menu.set_value(easy_toggle, false)
    menu.set_value(hard_toggle, false)
end

local function set_hard()
    current_drift_difficulty = drift_difficulty_levels.hard
    menu.set_value(easy_toggle, false)
    menu.set_value(normal_toggle, false)
end

easy_toggle = menu.toggle(vscript, "Drift Difficulty: Easy", {}, "", function(state)
    if state then set_easy() end
end)

normal_toggle = menu.toggle(vscript, "Drift Difficulty: Normal", {}, "", function(state)
    if state then set_normal() end
end, true)

hard_toggle = menu.toggle(vscript, "Drift Difficulty: Hard", {}, "", function(state)
    if state then set_hard() end
end)

local function get_drift_angle(vx, vy)
    local theta = math.atan2(vx, vy)
    return math.abs(math.floor(math.deg(theta)))
end

local function get_drift()
    local car = entities.get_user_vehicle_as_handle(true)

    local speed_vector = GET_ENTITY_SPEED_VECTOR(car, true)
    local speed = math.floor(GET_ENTITY_SPEED(car) * 3.6)
    local vx = speed_vector.x
    local vy = speed_vector.y

    update_v_history(vx_history, vx)
    update_v_history(vy_history, vy)

    local avg_vx = calculate_average(vx_history)
    local avg_vy = calculate_average(vy_history)

    local drift_angle = get_drift_angle(avg_vx, avg_vy)
    if min_drift_speed > speed then
        drift_angle = 0
    end
    local is_drifting = drift_angle > current_drift_difficulty

    if is_drifting and not prev_is_drifting then
        drift_start_time = util.current_unix_time_seconds()
    end

    if is_drifting then
        prev_is_drifting = true
        frames_not_drifting = 0
    elseif drift_angle <= current_drift_difficulty / 3 then
        frames_not_drifting = frames_not_drifting + 1
        if frames_not_drifting >= not_drifting_delay_frames then
            prev_is_drifting = false
        end
    else
        frames_not_drifting = 0
    end
end

local function update_drift_score()
    local car = entities.get_user_vehicle_as_handle(true)
    if prev_is_drifting then
        local current_time = util.current_unix_time_seconds()
        local drift_duration = current_time - drift_start_time

        local speed_vector = GET_ENTITY_SPEED_VECTOR(car, true)
        local vx = speed_vector.x
        local vy = speed_vector.y

        local drift_angle = get_drift_angle(vx, vy)
        local base_score = math.log(math.floor(drift_duration * drift_angle))
        base_score = base_score / 10

        local drift_multiplier = 1.0

        if vx > 1.5 * drift_angle then
            drift_multiplier = 1.5
            base_score = base_score * drift_multiplier
            util.toast("Drift Multiplier: " .. drift_multiplier)
        elseif vx > 2.0 * drift_angle then
            drift_multiplier = 2.0
            base_score = base_score * drift_multiplier
            util.toast("Drift Multiplier: " .. drift_multiplier)
        end

        if drift_duration > 10 then
            drift_multiplier = 10 * drift_multiplier
            base_score = base_score * drift_multiplier
            util.toast("Drift Multiplier: " .. drift_multiplier)
        end

        if base_score > 0 then
            current_drift_score = current_drift_score + base_score
        end

        if current_drift_score > highest_drift_score then
            highest_drift_score = current_drift_score
        end
    else
        current_drift_score = 0
    end
end

local function draw_hud_extra(vehicle_health, gear, ping, packet_loss)
    local in_car = IS_PED_IN_ANY_VEHICLE(players.user_ped(), false)
    local car = entities.get_user_vehicle_as_handle(true)
    local speed_vector = GET_ENTITY_SPEED_VECTOR(car, true)
    local vx = speed_vector.x
    local vy = speed_vector.y
    local vz = speed_vector.z
    local drift_indicator_radius = 0.003
    local drift_indicator_position = { x = 0.5015, y = 0.83 }

    if vy < 0 then
        gear = "R"
    elseif math.floor(vy) == 0 and in_car then
        gear = "0"
    elseif math.floor(vy) == 0 and not in_car then
        gear = "P"
    end
    local damage = vehicle_health

    --directx.draw_text(0.50, 0.9, tostring(gear), ALIGN_CENTRE, 1.0, colors.yellow, true)
    draw_text(tostring(gear), 0.495, 0.88, 0.17, colors.red)
    directx.draw_circle(0.5015, 0.9015, 0.02, colors.smoke)

    directx.draw_text(0.45, 0.96, "Damage", ALIGN_CENTRE, 0.5, colors.yellow, true)
    draw_segmented_vertical_bar(vehicle_health, 1.0, 0.45, 0.85, 0.003, 0.1, colors.red, colors.green, colors.smoke, 10, 0.002)

    local is_drifting = prev_is_drifting
    update_drift_score()

    local indicator_color = is_drifting and colors.green or colors.smoke
    directx.draw_circle(drift_indicator_position.x, drift_indicator_position.y, drift_indicator_radius, indicator_color)
    directx.draw_text(drift_indicator_position.x, drift_indicator_position.y + 0.02, "Drift", ALIGN_CENTRE, 0.5, colors.yellow, true)

    directx.draw_text(0.45, 0.818, "Current Score:", ALIGN_CENTRE, 0.45, colors.yellow, true)
    draw_text(tostring(math.floor(current_drift_score)), 0.427, 0.828, 0.05, colors.red)
    directx.draw_text(0.55, 0.818, "Highest Score:", ALIGN_CENTRE, 0.45, colors.yellow, true)
    draw_text(tostring(math.floor(highest_drift_score)), 0.527, 0.828, 0.05, colors.red)

    drift_angle = get_drift_angle(vx, vy)
    if drift_angle == 180 then
        drift_angle = 0
    end

    local padded_angle = string.format("%03d", drift_angle)
    directx.draw_text(0.548, 0.92, "Angle", ALIGN_CENTRE, 0.5, colors.yellow, true)
    draw_text(padded_angle, 0.538, 0.89, 0.07, colors.red)
end

menu.toggle_loop(vscript, "Dash", { "venabledash" }, "Speedometer/Tachometer &c.", function()
    local car_ptr = entities.get_user_vehicle_as_pointer(true)
    if car_ptr ~= 0 then
        local car = entities.pointer_to_handle(car_ptr)
        local speed = math.ceil(GET_ENTITY_SPEED(car) * 3.6)
        local max_speed = menu.get_value(menu.ref_by_path("Vehicle>Movement>Speed Limit (KMH)"))
        local rpm = math.ceil(_GET_VEHICLE_CURRENT_REV_RATIO(car) * 100)
        local gear = _GET_VEHICLE_CURRENT_DRIVE_GEAR(car)
        local vehicle_health = GET_ENTITY_HEALTH(car) / GET_ENTITY_MAX_HEALTH(car)

        draw_gauge_background()
        draw_gauge_speed(0.4, 1.0, speed, max_speed)
        draw_gauge_rpm(0.6, 1.025, rpm, 100)
        get_drift()
        draw_hud_extra(vehicle_health, gear)
    end
end)

-- Toggle between 55 and 70 degree FoV
menu.toggle(vscript, "Wide View", { "vwideview" }, "Increase the field of view.",
            function(on)
                set_FoV(on)
            end)


-- Toggle the HUD
menu.toggle(vscript, "Disable HUD", { "vdisablehud" }, "Turn off the HUD.",
            function(is_enabled)
                toggle_HUD(not is_enabled)
            end)


-- Toggle the radar
menu.toggle(vscript, "Disable Radar", { "vdisableradar" }, "Turn off the radar.",
            function(is_enabled)
                toggle_radar(is_enabled)
            end)

-- Toggle menu item for radar zoom
menu.toggle_loop(vscript, "Better Radar", { "vbetterradar" }, "The coverage of big map at the size of little map.",
                 function(on)
                     better_radar_enabled = on
                     enforce_radar_zoom()
                 end)

-- Mute the sirens, keep the lights
menu.toggle(vscript, "Better Bootlicker", { "vbetterbootlicker" }, "Disable the annoying sirens in cop cars.",
            function(on)
                toggle_muted_sirens(on)
            end)

-- Disable cover
menu.toggle(vscript, "Disable Cover", { "vdisablecover" }, "Disable cover (for controller players)",
            function(on)
                toggle_cover(not on)
            end)


-- Show FPS bar
menu.toggle_loop(vscript, "Show FPS Bar", {"vfpsbar"},
                 "",
                 function()
                     local gauge_length = 0.1
                     local gauge_height = 0.0025
                     local x = 0.5 - gauge_length * 0.5
                     local y = 0.99
                     draw_fps_bar(x, y, gauge_length, gauge_height)
                 end)

util.keep_running()
