util.require_natives("3095a.g")

local vscript = menu.my_root()
menu.divider(vscript, "vscript")

local wide_view = 70
local narrow_view = 55
local better_radar_enabled = false
local prev_is_drifting = false
local lateral_speed_threshold = 7.0
local history_size = 20
local vx_history = {}
local not_drifting_delay_frames = 15
local frames_not_drifting = 0
local is_drifting = false
local drift_start_time = 0
local current_drift_score = 0
local highest_drift_score = 0
hud_opacity_factor = 255

menu.trigger_commands("sleekminimap on")


local colors = {}

local function update_colors()
    colors.black = {
        ["r"] = 0.0,
        ["g"] = 0.0,
        ["b"] = 0.0,
        ["a"] = 0.8 * (hud_opacity_factor / 255)
    }

    colors.white = {
        ["r"] = 1.0,
        ["g"] = 1.0,
        ["b"] = 1.0,
        ["a"] = 0.15 * (hud_opacity_factor / 255)
    }

    colors.yellow = {
        ["r"] = 1.0,
        ["g"] = 153.0/255,
        ["b"] = 0.0,
        ["a"] = 0.4 * (hud_opacity_factor / 255)
    }

    colors.green = {
        ["r"] = 39.0/255,
        ["g"] = 177.0/255,
        ["b"] = 70.0/255,
        ["a"] = 0.4 * (hud_opacity_factor / 255)
    }

    colors.magenta = {
        ["r"] = 128.0/255,
        ["g"] = 0.0/255,
        ["b"] = 128.0/255,
        ["a"] = 0.5 * (hud_opacity_factor / 255)
    }

    colors.red = {
        ["r"] = 189.0/255,
        ["g"] = 0.0/255,
        ["b"] = 26.0/255,
        ["a"] = 0.8 * (hud_opacity_factor / 255)
    }
    colors.transparent = {
        ["r"] = 0.0,
        ["g"] = 0.0,
        ["b"] = 0.0,
        ["a"] = 0.0
    }
    colors.smoke = {
        ["r"] = 0.1,
        ["g"] = 0.1,
        ["b"] = 0.1,
        ["a"] = 0.3 * (hud_opacity_factor / 255)
    }
end

update_colors()

local function bezier_quadratic(p0, p1, p2, t)
    local u = 1 - t
    local tt = t * t
    local uu = u * u
    local x = (uu * p0.x) + (2 * u * t * p1.x) + (tt * p2.x)
    local y = (uu * p0.y) + (2 * u * t * p1.y) + (tt * p2.y)
    return { x = x, y = y }
end

local function draw_quadratic_bezier_curve(p0, p1, p2, segments, color)
    local last_point = p0
    for i = 1, segments do
        local t = i / segments
        local point = bezier_quadratic(p0, p1, p2, t)
        directx.draw_line(last_point.x, last_point.y, point.x, point.y, color)
        last_point = point
    end
end

menu.slider(vscript, "Dash Opacity", {}, "Set the dash opacity.", 0,
            255, hud_opacity_factor, 1,
            function(value)
                hud_opacity_factor = value
                update_colors()
end)

local function set_FoV(is_wide)
    SET_GAMEPLAY_CAM_RELATIVE_HEADING(0.0)
    SET_FOLLOW_PED_CAM_VIEW_MODE(2)
    local fov = is_wide and wide_view or narrow_view
    menu.trigger_commands("fovtponfoot " .. fov)
    menu.trigger_commands("fovtpinveh " .. fov)
    util.toast("Wide View: " .. (is_wide and "Active" or "Disabled") .. " (" .. fov .. " degrees)")
end

local function toggle_radar(is_enabled)
    DISPLAY_RADAR(not is_enabled)
end

local function toggle_HUD(is_enabled)
    DISPLAY_HUD(is_enabled)
    FORCE_OFF_WANTED_STAR_FLASH(not is_enabled)
    DISPLAY_CASH(is_enabled)
    DISPLAY_AREA_NAME(is_enabled)
end

local function enforce_radar_zoom()
    SET_RADAR_ZOOM(better_radar_enabled and 1400 or 1400)
    SET_BIGMAP_ACTIVE(false, false)
end

util.on_transition_finished(function()
                                enforce_radar_zoom()
end)

local function toggle_muted_sirens(is_muted)
    local vehicle = GET_VEHICLE_PED_IS_USING(players.user_ped())
    SET_VEHICLE_HAS_MUTED_SIRENS(vehicle, is_muted)
end

-- Function to toggle cover.  Thanks Drizz
local function toggle_cover(is_enabled)
    SET_PLAYER_CAN_USE_COVER(players.user(), is_enabled)
end

local function get_fps_color(fps)
    if fps >= 28 then
        return colors.green
    elseif fps >= 20 then
        return colors.yellow
    else
        return colors.red
    end
end

local function draw_fps(x, y)
    local fps = util.get_tps()
    local color = get_fps_color(fps)
    directx.draw_text_client(x, y, tostring(fps) .. " FPS", ALIGN_LEFT, 1.0, color, false)
end

local function draw_fps_bar(x, y, width, height)
    local max_fps = 30
    local fps = math.min(math.floor(util.get_tps()), max_fps)
    local bar_width = (fps / max_fps) * width
    local color = get_fps_color(fps)
    directx.draw_rect_client(x, y, bar_width, height, color)
end


function draw_pulsing_filled_rectangle(x, y, width, height, color, pulse_speed, time)
    directx.draw_rect_client(x, y, width, height, pulsing_color)
end

local function interpolate_color(color1, color2, factor)
    return {
        r = color1.r * (1 - factor) + color2.r * factor,
        g = color1.g * (1 - factor) + color2.g * factor,
        b = color1.b * (1 - factor) + color2.b * factor,
        a = color1.a * (1 - factor) + color2.a * factor
    }
end

local function draw_gauge_background()
    local radius = 0.32
    local pos_x = 0.5
    local pos_y = 1.35
    local circle_colour = {r = 255/255, g = 153/255, b = 0/255, a = 0.02 * hud_opacity_factor / 255}
    local triangle_side_length = 0.27
    local triangle_color = colors.black
    local height = triangle_side_length * math.sqrt(3) / 2
    local mid_center_x = 0.5
    local center_y = 0.92
    local left_center_x = mid_center_x - triangle_side_length / 2
    local right_center_x = mid_center_x + triangle_side_length / 2
    local triangle_vertices = {
        mid_center_x - triangle_side_length / 2, center_y - height / 2,
        mid_center_x + triangle_side_length / 2, center_y - height / 2,
        mid_center_x, center_y + height / 2
    }
    directx.draw_triangle(
        triangle_vertices[1], triangle_vertices[2],
        triangle_vertices[3], triangle_vertices[4],
        triangle_vertices[5], triangle_vertices[6],
        triangle_color
    )
    local left_center_x = mid_center_x - triangle_side_length / 2
    local inverted_triangle_vertices = {
        left_center_x + triangle_side_length / 2, center_y + height / 2,
        left_center_x - triangle_side_length / 2, center_y + height / 2,
        left_center_x, center_y - height / 2
    }

    directx.draw_triangle(
        inverted_triangle_vertices[1], inverted_triangle_vertices[2],
        inverted_triangle_vertices[3], inverted_triangle_vertices[4],
        inverted_triangle_vertices[5], inverted_triangle_vertices[6],
        triangle_color
    )

    local right_center_x = mid_center_x + triangle_side_length / 2
    local inverted_triangle_vertices = {
        right_center_x + triangle_side_length / 2, center_y + height / 2,
        right_center_x - triangle_side_length / 2, center_y + height / 2,
        right_center_x, center_y - height / 2
    }

    directx.draw_triangle(
        inverted_triangle_vertices[1], inverted_triangle_vertices[2],
        inverted_triangle_vertices[3], inverted_triangle_vertices[4],
        inverted_triangle_vertices[5], inverted_triangle_vertices[6],
        triangle_color
    )
    --directx.draw_circle(pos_x, pos_y, radius, circle_colour, 2)
    --directx.draw_circle(pos_x, pos_y, radius, circle_colour, 3)

    local shift_y = -0.14
    local segments = 300
    local p0 = { x = pos_x - 1.13 * radius , y = pos_y + shift_y}
    local p1 = { x = pos_x, y = 0.5 + shift_y} -- Control point for the curve
    local p2 = { x = pos_x + 1.13 * radius , y = pos_y + shift_y}

    -- draw_quadratic_bezier_curve(p0, p1, p2, segments, {r=1.0,g=1.0,b=1.0,a=1.0})
end

local function draw_gauge_foreground()
    local radius = 0.32
    local pos_x = 0.5
    local pos_y = 1.54
    local color = {r = 1.0, g = 1.0, b = 1.0, a = 1.0}
    color.a = 0.01
    directx.draw_circle(pos_x, pos_y - 0.01, radius - 0.005, color, 2)
    directx.draw_circle(pos_x, pos_y - 0.01, radius - 0.005, color, 3)
end

local function draw_numeric_display(value, pos_x, pos_y, scale, color)
    directx.draw_text(pos_x, pos_y, string.format("%03d", value),
                      ALIGN_CENTRE, scale, color, true)
end

local function draw_segment_bar_speed(pos_x, pos_y, width, height, segments, active_segments)
    local segment_height = (height / segments) * 1.5
    local curve_intensity = 0.7
    local shift_intensity = 0.6

    for i = 0, segments - 1 do
        local y = pos_y - (i * segment_height) - (segment_height * 1.5)
        local x_offset = (i / segments)^3 * curve_intensity - 0.1
        local segment_width = width * (1 - (i / segments) * 0.8)
        local x_shift = (i / segments)^3 * shift_intensity
        if i < active_segments then
            local color_factor = i / (segments - (segments * 0.05))
            local segment_color = interpolate_color(colors.green, colors.red, color_factor)
            directx.draw_rect(pos_x + x_offset - x_shift, y,
                              segment_width, segment_height - 0.005,
                              segment_color)
        else
            directx.draw_rect(pos_x + x_offset - x_shift,
                              y, segment_width, segment_height - 0.005, colors.smoke)
        end
    end
end

local function draw_gauge_speed(pos_x, pos_y, value, max_value)
    local bar_width = 0.1
    local bar_height = 0.1
    local segments = 20
    local active_segments = math.ceil((value / max_value) * segments)

    draw_segment_bar_speed(pos_x, pos_y, bar_width, bar_height, segments, active_segments)

    local num_pos_y = pos_y + bar_height - 0.2
    draw_numeric_display(value, pos_x, num_pos_y, 1.0, colors.yellow)
    directx.draw_text(pos_x, num_pos_y + 0.02, "KPH", ALIGN_CENTRE, 0.6, colors.yellow, true)
end

local function draw_segment_bar_rpm(pos_x, pos_y, width, height, segments, active_segments)
    local segment_width = (width / segments) * 1.2
    local curve_intensity = 0.12
    local shift_intensity = 0.05
    local pulse_speed = 10

    for i = 0, segments - 1 do
        local x = pos_x + (i * segment_width) - (segment_width * 1.5)
        local y_offset = - math.cos((i / segments) * math.pi) * curve_intensity - 0.1
        local segment_height = - height * (1 + (i / segments) * 0.8)
        local y_shift = - math.cos((i / segments) * math.pi) * shift_intensity

        if i < active_segments then
            local color_factor = i / (segments - (segments * 0.05))
            local segment_color = interpolate_color(colors.magenta, colors.red, color_factor)

            if active_segments >= segments then
                local pulse_factor = (math.sin(os.clock() * pulse_speed) + 1) / 2
                segment_color = interpolate_color(segment_color, colors.red, pulse_factor)
            end
            directx.draw_rect(x, pos_y + y_offset - y_shift,
                              segment_width - 0.005,
                              segment_height, segment_color)
        else
            directx.draw_rect(x, pos_y + y_offset - y_shift,
                              segment_width - 0.005,
                              segment_height, colors.smoke)
        end
    end
end

local function draw_gauge_rpm(pos_x, pos_y, value, max_value)
    local bar_width = 0.1
    local bar_height = 0.025
    local segments = 20
    local active_segments = math.ceil((value / max_value) * segments)

    draw_segment_bar_rpm(pos_x, pos_y, bar_width, bar_height, segments, active_segments)
    local num_pos_y = pos_y + bar_height - 0.15
    draw_numeric_display(value, pos_x, num_pos_y, 1.0, colors.yellow)
    directx.draw_text(pos_x, num_pos_y + 0.02, "% REV", ALIGN_CENTRE, 0.6, colors.yellow, true)
end

local function draw_segmented_vertical_bar(value, max_value, x, y,
                                           width, height, start_color,
                                           end_color, back_color, segments, gap)
    local bar_height = (value / max_value) * height
    local segment_height = (height / segments) - gap

    directx.draw_rect(x, y, width, height, back_color)

    for i = 0, segments - 1 do
        local segment_y = y + height - (i * (segment_height + gap)) - segment_height
        if segment_y >= y + height - bar_height then
            local color_factor = i / (segments - 1)

            local segment_color = interpolate_color(start_color, end_color, color_factor)
            directx.draw_rect(x, segment_y, width, segment_height, segment_color)
        else
            break
        end
    end
end

local function update_vx_history(vx)
    table.insert(vx_history, vx)
    if #vx_history > history_size then
        table.remove(vx_history, 1)
    end
end

local function calculate_average_vx()
    local sum = 0
    for _, v in ipairs(vx_history) do
        sum = sum + v
    end
    return sum / #vx_history
end

local function manage_drift_particle_fx(is_drifting)
    if is_drifting then
    local car = entities.get_user_vehicle_as_handle(true)
    USE_PARTICLE_FX_ASSET("ent_amb_fbi_fire_lg")
    START_NETWORKED_PARTICLE_FX_LOOPED_ON_ENTITY(
        "ent_amb_fbi_fire_lg",
        car,
        0.5,
        0.5,
        0.5,
        0.0,
        0.0,
        0.0,
        10.0,
        true,
        true,
        false,
        255,
        255,
        255,
        255
    )
    end
end

local function get_drift()
    local car = entities.get_user_vehicle_as_handle(true)

    local forward_x = GET_ENTITY_FORWARD_X(car)
    local forward_y = GET_ENTITY_FORWARD_Y(car)

    local speed_vector = GET_ENTITY_SPEED_VECTOR(car, true)
    local vx = speed_vector.x

    update_vx_history(vx)

    local avg_vx = calculate_average_vx()

    local is_drifting = math.abs(avg_vx) > lateral_speed_threshold and math.sqrt(forward_x * forward_x + forward_y * forward_y) > 0.1

    if is_drifting and not prev_is_drifting then
        drift_start_time = util.current_unix_time_seconds()
    end

    if is_drifting then
        prev_is_drifting = true
        frames_not_drifting = 0
    elseif math.abs(avg_vx) <= lateral_speed_threshold / 2 then
        frames_not_drifting = frames_not_drifting + 1
        if frames_not_drifting >= not_drifting_delay_frames then
            prev_is_drifting = false
        end
    else
        frames_not_drifting = 0
    end
end

local function update_drift_score()
    local car = entities.get_user_vehicle_as_handle(true)
    if prev_is_drifting then
        local current_time = util.current_unix_time_seconds()
        local drift_duration = current_time - drift_start_time

        local base_score = math.log(math.floor(drift_duration))

        local speed_vector = GET_ENTITY_SPEED_VECTOR(car, true)
        local vx = speed_vector.x

        if vx > 1.5 * lateral_speed_threshold then
            base_score = base_score * 1.5
        elseif vx > 2.0 * lateral_speed_threshold then
            base_score = base_score * 2.0
        end

        if drift_duration > 10 then
            base_score = base_score * 10
        end

        if base_score > 0 then
            current_drift_score = current_drift_score + base_score
        end

        if current_drift_score > highest_drift_score then
            highest_drift_score = current_drift_score
        end
    end

    if not prev_is_drifting then
        current_drift_score = 0
    end
end

local function draw_hud_extra(engine_health, body_health, gear, ping, packet_loss)
    local in_car = IS_PED_IN_ANY_VEHICLE(players.user_ped(), false)
    local car = entities.get_user_vehicle_as_handle(true)
    local speed_vector = GET_ENTITY_SPEED_VECTOR(car, true)
    local vx = speed_vector.x
    local vy = speed_vector.y
    local vz = speed_vector.z
    local drift_indicator_radius = 0.003
    local drift_indicator_position = { x = 0.5015, y = 0.83 }

    if vy < 0 then
        gear = "R"
    elseif math.floor(vy) == 0 and in_car then
        gear = "N"
    elseif math.floor(vy) == 0 and not in_car then
        gear = "P"
    end

    directx.draw_text_client(0.50, 0.9, tostring(gear), ALIGN_CENTRE, 1.0, colors.yellow, true)
    directx.draw_circle(0.5015, 0.9015, 0.02, colors.smoke)

    directx.draw_text(0.473, 0.96, "Performance", ALIGN_CENTRE, 0.5, colors.yellow, true)
    directx.draw_text(0.528, 0.96, "Cosmetic", ALIGN_CENTRE, 0.5, colors.yellow, true)
    draw_segmented_vertical_bar(engine_health, 1000, 0.47, 0.85, 0.008, 0.1, colors.red, colors.green, colors.smoke, 10, 0.002)
    draw_segmented_vertical_bar(body_health, 1000, 0.525, 0.85, 0.008, 0.1, colors.red, colors.green, colors.smoke, 10, 0.002)

    local is_drifting = prev_is_drifting
    update_drift_score()

    local indicator_color = is_drifting and colors.red or colors.smoke
    directx.draw_circle(drift_indicator_position.x, drift_indicator_position.y, drift_indicator_radius, indicator_color)
    directx.draw_text_client(drift_indicator_position.x, drift_indicator_position.y + 0.02, "Drift", ALIGN_CENTRE, 0.5, colors.yellow, true)

    local indicator_color = is_drifting and colors.red or colors.smoke
    directx.draw_circle(drift_indicator_position.x, drift_indicator_position.y, drift_indicator_radius, indicator_color)
    directx.draw_text_client(drift_indicator_position.x, drift_indicator_position.y + 0.02, "Drift", ALIGN_CENTRE, 0.5, colors.yellow, true)

directx.draw_text_client(0.45, 0.822, string.format("Current Score: %d", math.floor(current_drift_score)), ALIGN_CENTRE, 0.5, colors.yellow, true)
directx.draw_text_client(0.55, 0.822, string.format("Highest Score: %d", math.floor(highest_drift_score)), ALIGN_CENTRE, 0.5, colors.yellow, true)

    -- manage_drift_particle_fx(is_drifting)
end

menu.toggle_loop(vscript, "Dash", { "venabledash" }, "Speedometer/Tachometer &c.", function()
    local car_ptr = entities.get_user_vehicle_as_pointer(true)
    if car_ptr ~= 0 then
        local car = entities.pointer_to_handle(car_ptr)
        local speed = math.ceil(GET_ENTITY_SPEED(car) * 3.6)
        local max_speed = menu.get_value(menu.ref_by_path("Vehicle>Movement>Speed Limit (KMH)"))
        local rpm = math.ceil(_GET_VEHICLE_CURRENT_REV_RATIO(car) * 100)
        local gear = _GET_VEHICLE_CURRENT_DRIVE_GEAR(car)
        local engine_health = GET_VEHICLE_ENGINE_HEALTH(car)
        local body_health = GET_VEHICLE_BODY_HEALTH(car)

        draw_gauge_background()
        draw_gauge_speed(0.4, 1.0, speed, max_speed)
        draw_gauge_rpm(0.6, 1.025, rpm, 100)
        get_drift()
        draw_hud_extra(engine_health, body_health, gear)
    end
end)


-- Toggle between 55 and 70 degree FoV
menu.toggle(vscript, "Wide View", { "vwideview" }, "Increase the field of view.",
            function(on)
                set_FoV(on)
            end)


-- Toggle the HUD
menu.toggle(vscript, "Disable HUD", { "vdisablehud" }, "Turn off the HUD.",
            function(is_enabled)
                toggle_HUD(not is_enabled)
            end)


-- Toggle the radar
menu.toggle(vscript, "Disable Radar", { "vdisableradar" }, "Turn off the radar.",
            function(is_enabled)
                toggle_radar(is_enabled)
            end)

-- Toggle menu item for radar zoom
menu.toggle_loop(vscript, "Better Radar", { "vbetterradar" }, "The coverage of big map at the size of little map.",
                 function(on)
                     better_radar_enabled = on
                     enforce_radar_zoom()
                 end)

-- Mute the sirens, keep the lights
menu.toggle(vscript, "Better Bootlicker", { "vbetterbootlicker" }, "Disable the annoying sirens in cop cars.",
            function(on)
                toggle_muted_sirens(on)
            end)

-- Disable cover
menu.toggle(vscript, "Disable Cover", { "vdisablecover" }, "Disable cover (for controller players)",
            function(on)
                toggle_cover(not on)
            end)


-- Show FPS bar
menu.toggle_loop(vscript, "Show FPS Bar", {"vfpsbar"},
                 "",
                 function()
                     local gauge_length = 0.1
                     local gauge_height = 0.0025
                     local x = 0.5 - gauge_length * 0.5
                     local y = 0.99
                     draw_fps_bar(x, y, gauge_length, gauge_height)
                 end)

util.keep_running()
